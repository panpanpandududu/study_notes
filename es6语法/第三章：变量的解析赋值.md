### 1.数组的解构赋值

es6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，被称为解构。

以前，为变量赋值，只能直接指定值，如下所示：

```javascript
let a = 1;
let b = 2;
let c = 3;
```

es6允许写成如下形式

```javascript
let [a, b, c] = [1, 2, 3];
```

上述代码表示，可以从数组中提取值，按照对应位置，对变量赋值

本质上，这种写法属于"模式匹配"，只要等号两边的模式相同，左边的比那两就会被赋予对应的值。如下所示：

```js
    let a=[x, ,y]=[1,2,3];
    console.log(y);  //3

    let [ , ,third]=['foo','bar','baz'];
    console.log(third);  //baz

    let [foo,[[bar],baz]]=[1,[[2],3]];
    console.log(bar);  //2
    let [x, y, ...z] = ['a'];
    x // "a"
    y // undefined
    z // []
    //因为y解析不成功，所以值等于undefined，定义了y，但是没有值
    //还有一种有值，未定义变量，这种情况下可以解析成功,这种情况称为不完全解构
    let [x,y]=[1,2,3];
     x//1
     y//2
```

如果等号的右边不是数组（不是可遍历的结构），将会报错

```js
// 报错   is not iterable
let [foo] = 1;//转为对象后不具备Iterator接口
let [foo] = false;//转为对象后不具备Iterator接口
let [foo] = NaN;//转为对象后不具备Iterator接口
let [foo] = undefined;//转为对象后不具备Iterator接口
let [foo] = null;//转为对象后不具备Iterator接口
let [foo] = {}; //不具备Iterator 接口
```

对于**Set结构**，也可使用数组的解析赋值

```js
let  [x,y,z]=new Set(['a','b','c']);
x  //'a'
```

事实上，只要某种数据结构具有Iterator 接口，都可以采用数组形式的解构赋值

```javascript
function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}
let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
```

上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会一次从这个接口获取值

#### 扩展：

##### 迭代：**如果给定一个list(列表)或tuple(数组),通过for循环来遍历这个list或tuple，这种遍历我们称之为迭代**

注：在javascript中，[`Object`]是不可迭代的，除非他们实现了迭代协议，因此不可以用 [for…of ]来遍历迭代对象的属性

```js
  var obj = { 'France': 'Paris', 'England': 'London' };
  for (let p of obj) { 
  // TypeError: obj is not iterable  obj不可迭代
   console.log(11);  
   //es6可用
   }
```

作为替代必须使用`object.keys`或`object.entries`来迭代对象的属性或属性值。

**默认值**

 解构赋值允许指定默认值

```js
let [foo=true]=[];

foo  //true

let [x,y='b']=['a']; //x='a',y='b'
let [x,y='b']=['a',undefined]  //x='a',y='b'
```

注：es6内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。

```js
let [x=1]=[undefined];

x //1

let [y=1]=[null]

y //null
```

上述代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。

如果一个默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。

