#### 1.递归（例如树）总结（1.30日完成）

所谓递归，就是有去有回。

递归的基本思想，是把规模较大的一个问题，**分解**成规模较小的多个子问题去解决，而每一个子问题又可以继续拆分成多个更小的子问题。

最重要的一点就是假设子问题已经解决了，现在要基于已经解决的子问题来解决当前问题；或者说，必须先解决子问题，再基于子问题来解决当前问题。

**递归解决的是有依赖顺序关系的多个问题**

参考资料：

1.https://www.cnblogs.com/Pushy/p/8455862.html

2.https://blog.csdn.net/bobbypollo/article/details/79891556

3.https://blog.csdn.net/sun_DongLiang/article/details/82765451

递归通俗来说就是程序运行过程中自己调用自己，用少量程序多次重复计算，递归的能力即用**有限语句**来定义对象的**无限集合。**

一般来说，递归需要三个条件：**边界条件，递归前段，递归返回值**

当边界条件不满足时，继续前进，满足时，返回。

```js
  function func(num) {
    console.log("前行阶段");
    if (!num) { //递归终止条件
      console.log("递归在此结束");
    } else {
      func(--num); //递归调用
    }
    console.log("退回阶段");
  }
  func(1);
//输出
 前行阶段
 前行阶段
 递归在此结束
 退回阶段
 退回阶段
```

在上述代码中，`if (!num)`为边界条件，即递归调用的终止条件。在`else`代码块中递归调用函数，

递归的过程存在前行和退回阶段，在前行阶段中我们每次调用函数后会打印出`console.log("前行阶段");`，并且当num#0时，重新调用该函数；

函数递归实际也是一个狭义的递归，在执行函数func时，也调用了另外一个函数，只不过这个函数的代码和上个函数的代码一样，即本身。在此之前我们需了解机器层面的执行过程：

如下代码：

```js
function test(n){
     if(n == 1){ 
       return 1; 
     }else if(n <= 0){ 
       return 0; 
     }else{ 
       return n * test(n-1);
      } 
    } 
    console.log(test(5)); //120
```

此时需要引入**栈帧**的概念：

**1.栈帧将栈分割成n个记录快，每一个记录快的大小是不一样的；**

2.这个记录块实际上是编译器用来**实现函数调用的数据结构**，通俗来讲就是用于活动记录，**用于记录每次函数调用所涉及的相关信息的记录单元**；

3.**栈帧也是一个函数的执行环境，包括函数的参数，函数的局部变量函数，执行完返回到哪里**等等。

栈帧是用来调用函数的，每次调用就会形成一个栈帧，用来执行被调用函数的运行环境。所以上边的test函数在运行时就形成了一个又一个栈帧。

![img](https://img-blog.csdn.net/20180929205852699?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bl9Eb25nTGlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



#### 栈是一种先进后出的数据结构！！！

分析：上述代码要求计算出5的阶乘

1):首先调用test函数时传入5**，即在**栈**中划出一个记录块作为函数**test（5）的执行函数，执行到最后结果为**5*test(4)***；

2）：上一个函数的返回值中调用函数test（4），因此继续指向新的记录块，用于执行函数test（4）；执行到最后结果为： **4 * test（3**）；
3）：上一个函数的返回值中调用函数test（3），因此继续指向新的记录块，用于执行函数test（3）；执行到最后结果为： **3 * test（2）；**
4）：上一个函数的返回值中调用函数test（2），因此继续指向新的记录块，用于执行函数test（2）；执行到最后结果为： **2 * test（1**）；

5）：上一个函数的返回值中调用函数test（1），因此继续指向新的记录块，用于执行函数test（1）；执行到最后**test（1）=1**;

**此时进栈操作已经到达了递归终止的条件，为了计算出最后的test（5）的值需要执行出栈操作；**

![img](https://img-blog.csdn.net/20180929213058218?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1bl9Eb25nTGlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

如上图，我画了一幅出栈示意图；**栈是先进后出的，所以最后进的要先出**。
1）：test（1）出栈，返回值为1；
2）：栈帧test（2）接收test（1）返回值进行计算得出test（2） = 2 * 1 = 2；
3）：test（2）出栈，栈帧test（3）接收test（2）返回值进行计算得出test（3） = 3 * 2 = 6；
4）：test（3）出栈，栈帧test（4）接收test（3）返回值进行计算得出test（4） = 4 * 6 = 24；
5）：test（4）出栈，栈帧test（5）接收test（4）返回值进行计算得出test（5） = 5 * 24 = 120；

6）：test（5）出栈，返回值120，此时表示这一段程序已经执行完毕，计算得出5的阶乘是120；

###### 递归函数写到这一步，貌似是已经完美了，但是你有没有想过：每一个函数test（n） = n * test (n-1)因此每一个栈帧不仅需要保存n值还要记录下一个栈帧的返回值，然后才能计算出来当前栈帧的结果，因此使用多个栈帧是不可避免的，计算5的阶乘就使用了5个栈帧，那要是计算100的呢？10000的呢？。。。。这TM是不是有点始料未及了？栈的大小也是有限的，你就这么用下去，他不给你溢出才怪

#### 思考，因为栈的大小是有限的，当n=无穷大时栈肯定会溢出，如何优化？

答：**尾递归**

什么是尾递归？

**尾递归基于函数的尾调用，每一级调用直接返回函数的返回值更新调用栈，而不用创建新的调用栈，类似迭代的实现，时间和空间上都优化了一般递归**

```js
 function newTest(n,result){
    if (n=1){
      return result;
    }else {
       return newTest(n-1,n*result);
    }
 }
 console.log(newTest(5));
```

对于尾递归, 他的递归过程如下:

```js
`newTest(5)`

`newTest(5, 1)`

`newTest(4, 5)`

`newTest(3, 20)`

`newTest(2, 60)`

`newTest(1, 120)`

`120`
```

