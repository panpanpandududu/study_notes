#### 1.下面函数将打印出什么？

```js
var b=10;
(function b(){
    b=20;
    console.log(b);
})();
//打印结果为函数b
ƒ b(){
		b=20;
		console.log(b);
	}
```

##### 扩展:想到另一个有意思的函数自执行

```js
var b=10;
(function {
    b=20;
    console.log(b);
})();
```

上述代码实际相当于将两个函数合成一个函数，如下所示

```js
var b=10;
var f=function b(){
    b=20;
    console.log(b); //20
}
var j=f();
```

#### 延伸扩展

#### js中(function(){}()),(function(){})(),$(function(){});之间的区别

#### 1. (function(){}())与(function(){})()

```js
//A
(function(){      
console.log("a")
}());
//B
(function(){
   console.log("b") 
})();
```

上述AB均为立即函数执行的写法，这种函数在函数定义的地方就开始执行了。

```js
let name = 'World!';
(function () {
    if (typeof test_name === 'undefined') {
        test_name = 'Jack'; 
        console.log('Hello ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();

//打印结果：Goodbye Jack
```

**为什么上述结果为Jack？**

**变量查找是从局部开始，若局部没有，就访问外部，知识点来了，敲黑板。在这个自执行函数体内，我们发现有个`var name='Jack'`，**JavaScript 中，**函数及变量的声明都将被提升到函数的最顶部，所以此时在函数体内，将变量name提升到函数顶部，但是未使用，所以为undefined。**

#### 注：函数自执行的this指向都是window，如下又可以扩展

```js
let name = 'World!';
(function () {
        console.log('Hello ' + this.name);  //Hello 
})();

let tes_name = 'World!';
(function () {
        console.log('Hello ' + this.tes_name); //Hello undefined
})();

```

上述代码我们可以看到几个奇怪的结果,没有得到我们想要的hello world!，我们把函数拆分解读，上述代码可以看为如下编译顺序

```js
//A
(function () {
        console.log('Hello ' + this.test_name);
})();
window.test_name = 'World!';

//B
(function () {
        console.log('Hello ' + this.name);
})();
window.name = 'World!';
//函数自执行的时候window.test_name为undefined
```

注意：这里的window.name为什么不是undefined呢，敲黑板来了，window内置有个name属性，且为字符串’ ’

这里会牵扯到window跨域问题





