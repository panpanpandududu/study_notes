## 闭包

定义：是**函数和声明该函数的词法环境组合**

### 大前提：作用域**和**词法作用域

了解闭包之前先了解下**作用域**和**词法作用域**

词法作用域是作用域的一种**工作模型**

#### 作用域：简言之**作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）的规则**，即主要查找变量（标识符）。从内层一步步往外层查找变量，称之为**作用域链**，如下图所示

![img](https://upload-images.jianshu.io/upload_images/2555024-02eecfe91721a54e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)

#### 作用域中变量的查找规则

因为js是有编译过程的，比如简单的一行代码`var name='xiaoming'`,这行代码中有两个动作

- 编译器在当前作用域中声明一个变量name;
- 运行时引擎在作用域中查找该变量，找到之后为其赋值

代码案例如下：

```js
console.log（name）；   //undefined
var name='xiaoming';
```

上面的这段简单的代码包含两种查找类型：输出变量的值的时候的查找类型是RHS，找到变量为其赋值的查找类型是LHS。

“L”和“R”的含义，这里的左侧和右侧指的是在赋值操作的左侧和右侧。也就是说，变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。

用一句通俗的话来讲，**RHS就是取到它的源值,在作用域中查找变量都是RHS,所有的赋值操作中查找变量都是LHS**

所谓的词法作用域就是**在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了**。

如下代码所示：

```js
function fn1(x){
    var y=x+4;
    function fn2(z){
        console.log(x,y,z);
    }
    f2(y*5);
}
console.log(fn1(6));  //6 10 50

```

![img](https://upload-images.jianshu.io/upload_images/2555024-3841530f893072b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

分析上述代码的作用域：

A：全局作用域，有个标识符fn1();

B:fn1创建的作用域，有三个标识符x,y,fn2

C:fn2创建的作用域，有一个标识符 z

**作用域是由期代码写在哪里决定的，并且是逐级包含的**。

在此强调，词法作用域就是作用域是由书写代码时函数声明的位置来决定的。编译阶段就能够知道全部标识符在哪里以及是如何声明的，所以词法作用域是静态的作用域，也就是词法作用域能够预测在执行代码的过程中如何查找标识符。

**注1**：eval()和with可以通过其特殊性用来“欺骗”词法作用域，不过正常情况下都不建议使用，会产生性能问题。

**注2**：ES6中有了let、const就有了块级作用域

### 闭包作用

闭包是由函数以及创建该函数的词法环境组合而成。**这个环境包含了这个闭包创建时所能访问的所有局部变量**。**即子函数可以使用父函数中的局部变量.**保护了函数变量安全.因为闭包中的变量是内存维护,其它函数引用不到.

#### 应用场景：

#### 1.函数作为返回值。

如下代码：

```js
function func(x){
    return function(y){
        return x+y;
    }
}
//add5实际上是执行func函数时返回的function(y)函数实例的引用
var add5=func(5);  //5指的是参数x
console.log(add5(2));  //2指的是参数y
```

#### 2.函数作为参数传递











